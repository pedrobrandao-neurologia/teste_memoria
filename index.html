<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>M@T Digital — Teste de Alteração da Memória (v1.0.4)</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.28/jspdf.plugin.autotable.min.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet" />
  <style>
    :root{ --primary:#3b82f6; --primary-600:#2563eb; }
    html,body{height:100%}
    body{font-family:'Inter',system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,'Helvetica Neue','Noto Sans',sans-serif;background:#f3f4f6}
    .card{background:#fff;border-radius:1rem;box-shadow:0 10px 15px -3px rgba(0,0,0,.1),0 4px 6px -2px rgba(0,0,0,.05);padding:1.25rem}
    @media(min-width:640px){.card{padding:2rem}}
    .btn{display:inline-flex;align-items:center;justify-content:center;gap:.5rem;border:none;border-radius:.75rem;padding:.875rem 1.25rem;font-weight:600;color:#fff;background:var(--primary);cursor:pointer;transition:all .2s}
    .btn:disabled{opacity:.6;cursor:not-allowed}
    .btn:hover:not(:disabled){background:var(--primary-600)}
    .btn-secondary{background:#6b7280}
    .btn-secondary:hover{background:#4b5563}
    .option-grid{display:grid;grid-template-columns:1fr;gap:.75rem}
    @media(min-width:640px){.option-grid{grid-template-columns:repeat(2,1fr)}}
    .option-btn{width:100%;padding:1rem;border:2px solid #e5e7eb;border-radius:.75rem;background:#f9fafb;text-align:left;cursor:pointer;transition:.15s}
    .option-btn:hover:not(:disabled){background:#f3f4f6;border-color:var(--primary)}
    .option-btn.selected{background:#dbeafe;border-color:var(--primary);font-weight:600}
    .option-btn.correct{background:#dcfce7;border-color:#22c55e;color:#166534;font-weight:700}
    .option-btn.incorrect{background:#fee2e2;border-color:#ef4444;color:#991b1b}
    .option-btn:disabled{opacity:.7;cursor:not-allowed}
    .input{width:100%;padding:.75rem 1rem;border:2px solid #e5e7eb;border-radius:.75rem}
    .input:focus{outline:none;border-color:var(--primary)}
    .progress{height:.5rem;background:#e5e7eb;border-radius:9999px;overflow:hidden}
    .progress > div{height:100%;background:var(--primary);width:0%;transition:width .3s ease}
    .badge-audio{display:none;align-items:center;gap:.4rem;background:#fef3c7;border:1px solid #fbbf24;color:#92400e;padding:.25rem .6rem;border-radius:9999px;font-size:.875rem}
    @keyframes pulse{0%,100%{opacity:1}50%{opacity:.7}}
    .pulse{animation:pulse 2s infinite}
    .badge-mic{display:none;align-items:center;gap:.4rem;background:#dcfce7;border:1px solid #22c55e;color:#166534;padding:.25rem .6rem;border-radius:9999px;font-size:.875rem}
    .record-dot{width:8px;height:8px;border-radius:50%;background:#ef4444;animation:pulse 1.2s infinite}
  </style>
</head>
<body class="min-h-screen p-4 grid place-items-center">
  <main id="app" class="card w-full max-w-[760px]"></main>

  <script>
    // ==============================
    // CONFIGURAÇÃO DO TESTE
    // ==============================
    const TEST_VERSION = 'MAT-Digital 1.0.4';
    const ISI_MS = 1000;         // Intervalo entre estímulos (palavras)
    const SENTENCE_ISI_MS = 2000;  // Intervalo após frase
    const MAX_FREE_RECALL_WORDS = 5;

    // Estrutura de blocos
    const blocks = {
      codificacao: [
        {type:'instruction', text:'Agora vou dizer 5 palavras. Ouça com atenção e tente memorizá-las.'},
        {type:'word', item:'Cereja'},
        {type:'word', item:'Machado'},
        {type:'word', item:'Elefante'},
        {type:'word', item:'Piano'},
        {type:'word', item:'Verde'},
        {type:'instruction', text:'Agora responda às perguntas.'},
        {type:'mc', prompt:'Eu lhe disse o nome de uma fruta, qual era?', options:['Maçã','Cereja','Banana','Uva'], answer:'Cereja', cue:'Qual era a fruta?'},
        {type:'mc', prompt:'Eu lhe disse o nome de uma ferramenta, qual era?', options:['Serrote','Alicate','Machado','Martelo'], answer:'Machado', cue:'Qual era a ferramenta?'},
        {type:'mc', prompt:'Eu lhe disse o nome de um animal, qual era?', options:['Cachorro','Gato','Leão','Elefante'], answer:'Elefante', cue:'Qual era o animal?'},
        {type:'mc', prompt:'Eu lhe disse o nome de um instrumento musical, qual era?', options:['Violino','Piano','Flauta','Bateria'], answer:'Piano', cue:'Qual era o instrumento musical?'},
        {type:'mc', prompt:'Eu lhe disse o nome de uma cor, qual era?', options:['Azul','Vermelho','Verde','Amarelo'], answer:'Verde', cue:'Qual era a cor?'},
        {type:'instruction', text:'Agora ouça a primeira frase.'},
        {type:'sentence', sentence:'Trinta gatos cinzas comeram todo o queijo.'},
        {type:'mc-sent', ref:'Trinta gatos cinzas comeram todo o queijo.', questions:[
          {prompt:'Da frase sobre os gatos, quantos gatos eram?', options:['Vinte','Trinta','Quarenta'], answer:'Trinta'},
          {prompt:'Qual era a cor dos gatos?', options:['Pretos','Brancos','Cinzas'], answer:'Cinzas'},
          {prompt:'O que eles comeram?', options:['Peixe','Rato','Queijo'], answer:'Queijo'}
        ], recall_items:['Trinta','Cinzas','Queijo']},
        {type:'instruction', text:'Agora ouça a segunda frase.'},
        {type:'sentence', sentence:'Um garoto chamado Luís estava brincando com sua bicicleta.'},
        {type:'mc-sent', ref:'Um garoto chamado Luís estava brincando com sua bicicleta.', questions:[
          {prompt:'Da frase sobre o garoto, qual era o nome dele?', options:['Pedro','Luís','João'], answer:'Luís'},
          {prompt:'Com o que ele estava brincando?', options:['Bola','Carrinho','Bicicleta'], answer:'Bicicleta'}
        ], recall_items:['Luís','Bicicleta']},
      ],
      orientacao: [
        {type:'mc-dyn', prompt:'Que dia da semana é hoje?', get:'dayOfWeek'},
        {type:'mc-dyn', prompt:'Em que mês estamos?', get:'month'},
        {type:'input-dyn', prompt:'Qual é o dia do mês?', get:'dayOfMonth', input:'number'},
        {type:'input-dyn', prompt:'Em que ano estamos?', get:'year', input:'number'},
        {type:'mc-dyn', prompt:'Qual é a estação do ano?', get:'season'}
      ],
      semantica: [
        {type:'mc', prompt:'Qual profissional conserta carros?', options:['Mecânico','Eletricista','Encanador','Padeiro','Jardineiro'], answer:'Mecânico'},
        {type:'mc', prompt:'Qual é o último dia do ano?', options:['31 de Dezembro','30 de Dezembro','1 de Janeiro','25 de Dezembro','31 de Janeiro'], answer:'31 de Dezembro'},
        {type:'mc', prompt:'Quantas gramas há em um quarto de quilo?', options:['250g','500g','100g','750g','1000g'], answer:'250g'},
        {type:'mc', prompt:'Qual é o oitavo mês do ano?', options:['Agosto','Setembro','Julho','Outubro','Junho'], answer:'Agosto'},
        {type:'mc', prompt:'Em que mês comemoramos o Natal?', options:['Novembro','Janeiro','Dezembro','Fevereiro','Março'], answer:'Dezembro'},
        {type:'mc', prompt:'Se o relógio marca exatamente 11 horas, em qual número o ponteiro grande (minutos) deve estar?', options:['12','11','1','5','6'], answer:'12'},
        {type:'mc', prompt:'Qual estação do ano vem depois do verão?', options:['Outono','Inverno','Primavera'], answer:'Outono'},
        {type:'mc', prompt:'Que animal rasteja e não tem patas?', options:['Cachorro','Pássaro','Serpente','Peixe','Pinguim'], answer:'Serpente'},
        {type:'mc', prompt:'Azeitona vem de qual árvore?', options:['Videira','Oliveira','Macieira','Cerejeira','Laranjeira'], answer:'Oliveira'},
        {type:'mc', prompt:'De qual fruto se faz o chocolate?', options:['Café','Cacau','Morango','Cana-de-açúcar','Soja'], answer:'Cacau'},
        {type:'mc', prompt:'Qual o triplo de doze?', options:['24','36','48','30','15'], answer:'36'},
        {type:'mc', prompt:'Quantas horas há em dois dias?', options:['24 horas','36 horas','48 horas','72 horas','60 horas'], answer:'48 horas'},
        {type:'mc', prompt:'O que usamos para escrever em um quadro negro?', options:['Caneta','Giz','Lápis','Pincel','Tinta'], answer:'Giz'},
        {type:'mc', prompt:'Qual é a capital do Brasil?', options:['Rio de Janeiro','São Paulo','Brasília','Salvador','Belo Horizonte'], answer:'Brasília'},
        {type:'mc', prompt:'Quantos lados tem um triângulo?', options:['Três','Quatro','Cinco'], answer:'Três'}
      ]
    };

    // ==============================
    // ASR — Reconhecimento de voz (Web Speech API)
    // ==============================
    const asr = {
      SR: null, rec: null,
      init(){
        this.SR = window.SpeechRecognition || window.webkitSpeechRecognition || null;
        if (typeof state !== 'undefined' && state.speech){
          state.speech.supported = !!this.SR;
        }
      },
      start({mode}){
        if (!this.SR){ alert('Reconhecimento de voz não disponível neste navegador.'); return; }
        if (state.speech.listening){ this.stop(); }
        this.rec = new this.SR();
        this.rec.lang = 'pt-BR';
        this.rec.interimResults = true;
        this.rec.continuous = /recall/.test(mode);
        state.speech.listening = true;
        const mic = $('#badge-mic'); if (mic) mic.style.display='inline-flex';
        const transcriptEl = $('#voice-transcript');
        const finalize = (finalText) => {
          state.speech.utterances++;
          state.speech.log.push({t:Date.now(), text:finalText, mode});
          handleVoice(finalText, mode);
          if (!this.rec.continuous){ this.stop(); }
        };
        this.rec.onresult = (e)=>{
          let interim='', final='';
          for (let i = e.resultIndex; i < e.results.length; i++){
            const r = e.results[i];
            if (r.isFinal) final += r[0].transcript;
            else interim += r[0].transcript;
          }
          if (transcriptEl){ transcriptEl.textContent = (final||interim).trim(); }
          if (final){ finalize(final.trim()); }
        };
        this.rec.onerror = ()=>{ this.stop(); };
        this.rec.onend = ()=>{
          state.speech.listening=false;
          const badge = $('#badge-mic'); if (badge) badge.style.display='none';
        };
        this.rec.start();
      },
      stop(){
        try{ this.rec && this.rec.stop(); }catch(_){ }
        state.speech.listening=false;
        const badge = $('#badge-mic'); if (badge) badge.style.display='none';
      }
    };

    function handleVoice(text, mode){
      const s = normalize(text);
      if (/^(fim|finalizar|pronto)$/.test(s)){
        if (mode==='recall-words'){ $('[data-action="commit-recall-words"]')?.click(); return; }
        if (mode==='recall-sent'){ $('[data-action="commit-recall-sent"]')?.click(); return; }
      }
      if (mode==='mc' || mode==='cued'){
        const buttons = $$('.option-grid .option-btn');
        const opts = buttons.map(b=>b.textContent.trim());
        const idx = bestMatch(s, opts);
        const btn = buttons[idx];
        if (btn){
          btn.click();
          const submit = $('[data-action="submit"], [data-action="submit-cued"]');
          submit?.click?.();
        }
        return;
      }
      if (mode==='input'){
        const n = parsePtNumber(s);
        if (!Number.isNaN(n)){
          const inp = $('#free-input'); if (inp){ inp.value = String(n); }
          $('[data-action="submit"]')?.click();
        }
        return;
      }
      if (mode==='recall-words' || mode==='recall-sent'){
        const grid = $$('#recall-grid .option-btn');
        grid.forEach(b=>{
          const txt = b.textContent.trim();
          const match = lev(s, txt) <= 1 || s.split(' ').some(tok=>lev(tok, txt) <= 1);
          if (match){
            if (!b.classList.contains('selected')){
              if (b.getAttribute('data-kind')==='word'){
                const sel = $$('#recall-grid .option-btn.selected');
                if (sel.length >= MAX_FREE_RECALL_WORDS) return;
              }
              b.click();
            }
          }
        });
      }
    }

    function refreshVoiceUI(){
      const transcript = $('#voice-transcript');
      if (transcript) transcript.textContent = '';
      const starters = $$('.btn[data-action="voice-start"]');
      starters.forEach(btn=>{
        if (!state.speech.supported){
          btn.disabled = true;
          btn.title = 'Reconhecimento de voz indisponível neste dispositivo';
        } else {
          btn.disabled = false;
          btn.removeAttribute('title');
        }
      });
    }
    const FLOW = ['codificacao','orientacao','semantica','free_recall','cued_recall'];

    // ==============================
    // ESTADO GLOBAL
    // ==============================
    const app = document.getElementById('app');
    const state = {
      screen:'welcome',
      profile:{ age:'', education:'' },
      block:null, itemIndex:0, subIndex:0,
      startTime:null, endTime:null,
      answers:{}, scores:{ codificacao:0, orientacao:0, semantica:0, recuperacao_livre:0, recuperacao_pistas:0 },
      itemsToRecall:[], recallPhase:'words',
      selection:null, lastShownAt:null, rtLog:[], qc:[],
      ttsReady:false,
      orientationReference:null,
      recallStats:null,
      speech:{ supported:false, listening:false, utterances:0, log:[] }
    };

    // ==============================
    // UTILITÁRIOS
    // ==============================
    const $ = (sel,root=document) => root.querySelector(sel);
    const $$ = (sel,root=document) => [...root.querySelectorAll(sel)];
    const shuffle = (arr)=>{const a=[...arr];for(let i=a.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));[a[i],a[j]]=[a[j],a[i]]}return a};
    const normalize = (value)=>{
      if (value === null || value === undefined) return '';
      let str = String(value).trim();
      if (!str) return '';

      const numericCandidate = str.replace(',', '.');
      if (/^-?\d+(?:[\.,]\d+)?$/.test(str.replace(/\s+/g,''))){
        const num = Number(numericCandidate);
        if (!Number.isNaN(num)){
          return Number.isInteger(num) ? String(num) : String(num).replace(/\.0+$/,'');
        }
      }

      return str
        .normalize('NFD')
        .replace(/[\u0300-\u036f]/g,'')
        .replace(/[^a-z0-9]+/gi,' ')
        .trim()
        .toLowerCase();
    };
    const answersMatch = (a, b) => normalize(a) === normalize(b);

    // Conversor simples de números em pt-BR
    function parsePtNumber(str){
      if (!str) return NaN;
      const s = normalize(str).replace(/\bde\b/g,' ').replace(/\s+/g,' ').trim();
      if (/^\d+$/.test(s)) return parseInt(s,10);
      const units = {zero:0,um:1,uma:1,dois:2,duas:2,tres:3,quatro:4,cinco:5,seis:6,sete:7,oito:8,nove:9,dez:10,onze:11,doze:12,treze:13,quatorze:14,catorze:14,quinze:15,dezesseis:16,dezassete:17,dez7:17,dez7e:17,dezessete:17,dezoito:18,dezenove:19};
      const tens  = {vinte:20,trinta:30,quarenta:40,cinquenta:50,sessenta:60,setenta:70,oitenta:80,noventa:90};
      const hundreds = {cem:100,cento:100,duzentos:200,trezentos:300,quatrocentos:400,quinhentos:500,seiscentos:600,setecentos:700,oitocentos:800,novecentos:900};
      let total = 0, current = 0;
      const tokens = s.split(' ');
      for (let t of tokens){
        if (t==='e') continue;
        if (t in units){ current += units[t]; continue; }
        if (t in tens){ current += tens[t]; continue; }
        if (t in hundreds){ current += hundreds[t]; continue; }
        if (t==='mil'){ total += (current||1)*1000; current = 0; continue; }
      }
      const val = total + current;
      return val || NaN;
    }

    function lev(a,b){
      a = normalize(a); b = normalize(b);
      const m=a.length,n=b.length; const dp=Array.from({length:m+1},()=>Array(n+1).fill(0));
      for(let i=0;i<=m;i++) dp[i][0]=i;
      for(let j=0;j<=n;j++) dp[0][j]=j;
      for(let i=1;i<=m;i++){
        for(let j=1;j<=n;j++){
          const cost = a[i-1]===b[j-1]?0:1;
          dp[i][j]=Math.min(dp[i-1][j]+1,dp[i][j-1]+1,dp[i-1][j-1]+cost);
        }
      }
      return dp[m][n];
    }

    function bestMatch(spoken, options){
      const s = normalize(spoken);
      const nmap = { '1':['1','um','uma','primeira'], '2':['2','dois','duas','segunda'], '3':['3','tres','terceira'], '4':['4','quatro','quarta'], '5':['5','cinco','quinta'] };
      for (const [k,forms] of Object.entries(nmap)){
        if (forms.some(f=>s.includes(f))) return parseInt(k,10)-1;
      }
      if (/(nao (sei|lembro|recordo)|esqueci)/.test(s)) {
        const idx = options.findIndex(o=>normalize(o).includes('nao me recordo'));
        if (idx>=0) return idx;
      }
      let best=-1,score=1e9;
      options.forEach((o,i)=>{ const d=lev(s,o); if (d<score){score=d;best=i;} });
      return best;
    }

    const dynamic = (kind)=>{
      const now = (state.block === 'orientacao' && state.orientationReference)
        ? new Date(state.orientationReference)
        : new Date();
      const week = ['Domingo','Segunda-feira','Terça-feira','Quarta-feira','Quinta-feira','Sexta-feira','Sábado'];
      const months = ['Janeiro','Fevereiro','Março','Abril','Maio','Junho','Julho','Agosto','Setembro','Outubro','Novembro','Dezembro'];
      const m = now.getMonth();
      let season;
      // Hemisfério Sul (Brasil)
      if (m===11||m<=1) season='Verão';
      else if (m>=2 && m<=4) season='Outono';
      else if (m>=5 && m<=7) season='Inverno';
      else season='Primavera';
      switch(kind){
        case 'dayOfWeek': return { options:week, answer:week[now.getDay()] };
        case 'month': return { options:months, answer:months[m] };
        case 'season': return { options:['Verão','Outono','Inverno','Primavera'], answer:season };
        case 'dayOfMonth': return { answer:String(now.getDate()) };
        case 'year': return { answer:String(now.getFullYear()) };
        default: return {};
      }
    };

    const computeRecallStats = ()=>{
      const totalTargets = state.itemsToRecall.length;
      const freeHits = state.itemsToRecall.filter(i=>i.recalled === 'free').length;
      const cueHits = state.itemsToRecall.filter(i=>i.recalled === 'cued').length;
      const missed = state.itemsToRecall.filter(i=>i.recalled !== 'free' && i.recalled !== 'cued').length;
      const eligible = Math.max(0, totalTargets - freeHits);
      return { totalTargets, freeHits, cueHits, missed, eligible };
    };

    function summarizeRecall(){
      const stats = computeRecallStats();
      const enriched = { ...stats, autoAwarded: stats.eligible === 0 };
      state.recallStats = enriched;
      state.scores.recuperacao_livre = stats.freeHits;
      state.scores.recuperacao_pistas = stats.eligible === 0 ? stats.totalTargets : stats.cueHits;
      return enriched;
    }

    // ==============================
    // TTS (APENAS Web Speech API — sem serviços externos)
    // ==============================
    const tts = {
      enabled: true,
      selectedVoice: null,
      speakQueue: Promise.resolve(),
      readyPromise: null,
      preferredVoicePatterns: [
        /Microsoft (?:Maria|Antonio|Leila|Vit[oó]ria).*Natural.*Portuguese \(Brazil\)/i,
        /Microsoft .+Portuguese \(Brazil\)/i,
        /Google (?:portugu[êe]s do Brasil|brasileiro)/i,
        /Google.*pt-BR/i,
        /Luciana/i,
        /Felipe/i
      ],
      ensureReady(){
        if (!('speechSynthesis' in window)) { this.enabled=false; this.readyPromise = Promise.resolve(); return; }
        if (this.readyPromise) { return; }

        const finalizeSelection = () => {
          const voice = this.pickVoice();
          if (voice) {
            this.selectedVoice = voice;
            state.ttsReady = true;
            this.enabled = true;
          } else {
            this.enabled = false;
          }
        };

        this.readyPromise = new Promise(resolve => {
          const trySelect = () => {
            finalizeSelection();
            resolve();
          };

          try {
            window.speechSynthesis.cancel();
            const unlock = new SpeechSynthesisUtterance('');
            unlock.lang = 'pt-BR';
            window.speechSynthesis.speak(unlock);
          } catch (_) {
            this.enabled = false;
            resolve();
            return;
          }

          const immediate = window.speechSynthesis.getVoices();
          if (immediate && immediate.length) {
            trySelect();
            return;
          }

          const onVoicesChanged = () => {
            window.speechSynthesis.removeEventListener('voiceschanged', onVoicesChanged);
            trySelect();
          };

          window.speechSynthesis.addEventListener('voiceschanged', onVoicesChanged);
          setTimeout(trySelect, 1500); // fallback caso o evento não dispare
        });
      },
      pickVoice(){
        const voices = window.speechSynthesis?.getVoices?.() || [];
        const ptVoices = voices.filter(v=>/pt-?BR/i.test(v.lang));
        if (!ptVoices.length) { return null; }
        for (const pattern of this.preferredVoicePatterns){
          const match = ptVoices.find(v=>pattern.test(v.name));
          if (match) { return match; }
        }
        const def = ptVoices.find(v=>v.default);
        return def || ptVoices[0];
      },
      say(text, {rate=1.05, onend}={}){
        const badge = $('#badge-audio');
        if (badge) badge.style.display='inline-flex';

        if (!this.readyPromise) { this.ensureReady(); }

        this.speakQueue = this.speakQueue
          .then(() => this.readyPromise || Promise.resolve())
          .then(() => new Promise(res => {
            if (!this.enabled || !state.ttsReady) {
              if (badge) badge.style.display='none';
              if (onend) onend();
              res();
              return;
            }

            const utterance = new SpeechSynthesisUtterance(text);
            utterance.lang = 'pt-BR';
            utterance.rate = rate;
            utterance.voice = this.selectedVoice || this.pickVoice();
            if (!utterance.voice) {
              this.enabled = false;
              if (badge) badge.style.display='none';
              if (onend) onend();
              res();
              return;
            }

            utterance.onend = () => {
              if (badge) badge.style.display='none';
              if (onend) onend();
              res();
            };
            utterance.onerror = () => {
              if (badge) badge.style.display='none';
              if (onend) onend();
              res();
            };

            window.speechSynthesis.speak(utterance);
          }));
      }
    };

    // ==============================
    // RENDERIZAÇÃO BÁSICA
    // ==============================
    function header(title, showProgress=true){
      let pct = 0;
      if (showProgress && state.block){
        const totalStandard = Object.values(blocks).reduce((acc, arr)=> acc+arr.length,0);
        const special = 2; // free_recall + cued_recall
        const total = totalStandard + special;
        const currentBlockIndex = FLOW.indexOf(state.block);
        const donePrev = FLOW.slice(0,currentBlockIndex).reduce((acc,b)=> acc + (blocks[b]?.length||1),0);
        pct = Math.min(100, ((donePrev + (state.itemIndex||0)) / total) * 100);
      }
      return `
        <div class="flex items-center justify-between">
          <div>
            <h1 class="text-2xl font-bold text-gray-800">${title}</h1>
            <p class="text-xs text-gray-500">${TEST_VERSION}</p>
          </div>
          <div id="badge-audio" class="badge-audio pulse"><svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M9 18V5l12-2v13"/><circle cx="6" cy="18" r="3"/><circle cx="18" cy="16" r="3"/></svg>Reproduzindo</div>
          <div id="badge-mic" class="badge-mic"><span class="record-dot"></span> Ouvindo</div>
        </div>
        ${showProgress?`<div class="mt-4 progress"><div style="width:${pct}%"></div></div>`:'<div class="mt-6"></div>'}
      `;
    }

    function render(){
      switch(state.screen){
        case 'welcome': return renderWelcome();
        case 'profile': return renderProfile();
        case 'instructions': return renderInstructions();
        case 'test': return renderTest();
        case 'results': return renderResults();
      }
    }

    function renderWelcome(){
      app.innerHTML = `
        <section class="text-center">
          <h1 class="text-3xl font-bold text-gray-800">M@T Digital</h1>
          <p class="text-gray-600 mb-6">Teste de Alteração da Memória</p>
          <div class="text-left bg-blue-50 border border-blue-200 text-blue-900 rounded p-4 mb-6">
            <p class="font-semibold mb-2">Antes de começar:</p>
            <ul class="list-disc list-inside text-sm space-y-1">
              <li>Ambiente silencioso, sem interrupções.</li>
              <li>Duração aproximada: 10–15 minutos.</li>
              <li>Áudio necessário para instruções. Teste abaixo.</li>
            </ul>
          </div>
          <div class="flex items-center justify-center gap-3 mb-6">
            <button class="btn-secondary btn" data-action="test-audio">🔊 Testar áudio</button>
            <button class="btn" data-action="start-profile">Iniciar</button>
          </div>
        </section>
      `;
    }

    function renderProfile(){
      app.innerHTML = `
        ${header('Informações do Participante', false)}
        <div class="space-y-4">
          <label class="block">
            <span class="block text-sm font-medium text-gray-700">Idade (anos completos) <span class="text-red-500">*</span></span>
            <input id="age" type="number" min="18" max="120" class="input" value="${state.profile.age}" />
          </label>
          <label class="block">
            <span class="block text-sm font-medium text-gray-700">Escolaridade (anos de estudo) <span class="text-red-500">*</span></span>
            <input id="education" type="number" min="0" max="40" class="input" value="${state.profile.education}" />
          </label>
          <p id="profile-error" class="text-sm text-red-600 min-h-[20px]"></p>
          <div class="flex justify-end gap-3">
            <button class="btn-secondary btn" data-action="back">Voltar</button>
            <button class="btn" data-action="go-instructions">Continuar</button>
          </div>
        </div>
      `;
    }

    function renderInstructions(){
      const text = 'O teste começará agora. Você verá e ouvirá palavras, frases e perguntas. Responda tocando nos botões. Se não souber, selecione “Não me recordo”, quando disponível.';
      app.innerHTML = `
        ${header('Instruções', false)}
        <p class="text-gray-700 text-lg">${text}</p>
        <div class="mt-4 bg-yellow-50 border border-yellow-200 text-yellow-900 rounded p-3">
          <p class="font-semibold">Atenção</p>
          <p class="text-sm">Não use o botão voltar do navegador nem recarregue a página.</p>
        </div>
        <div class="flex justify-end gap-3 mt-6">
          <button class="btn-secondary btn" data-action="back-profile">Voltar</button>
          <button class="btn" data-action="start-test">Começar o teste</button>
        </div>
      `;
      tts.say(text);
    }

    function renderTest(){
      switch(state.block){
        case 'codificacao':
        case 'orientacao':
        case 'semantica':
          return renderQuestionBlock(state.block);
        case 'free_recall':
          return renderFreeRecall();
        case 'cued_recall':
          return renderCuedRecall();
      }
    }

    function renderQuestionBlock(blockName){
      if (blockName === 'orientacao' && !state.orientationReference){
        state.orientationReference = new Date();
      }
      const arr = blocks[blockName];
      const item = arr[state.itemIndex];
      if (!item) { return goNext(); }
      state.selection = null;
      state.lastShownAt = performance.now();

      let inner = '';
      const titleMap = {codificacao:'Memorização', orientacao:'Orientação no Tempo', semantica:'Conhecimentos Gerais'};
      const title = titleMap[blockName] || 'Teste';

      if (item.type === 'instruction'){
        inner = `
          ${header(title)}
          <p class="text-xl text-center my-8">${item.text}</p>
          <div class="text-center mt-6"><button class="btn" data-action="next">Continuar</button></div>
        `;
        tts.say(item.text);
      }
      else if (item.type === 'word'){
        inner = `
          ${header(title)}
          <div class="text-center my-16"><h2 class="text-5xl font-bold text-gray-800">${item.item}</h2></div>
        `;
        tts.say(item.item, { onend: ()=> setTimeout(goNext, ISI_MS) });
      }
      else if (item.type === 'sentence'){
        inner = `
          ${header(title)}
          <div class="text-center my-12 px-4"><h2 class="text-3xl font-semibold text-gray-800 leading-relaxed">${item.sentence}</h2></div>
        `;
        tts.say(item.sentence, { onend: ()=> setTimeout(goNext, SENTENCE_ISI_MS) });
      }
      else if (item.type === 'mc' || item.type === 'mc-sent' || item.type === 'mc-dyn' || item.type === 'input-dyn'){
        inner = questionUI(blockName, item);
      }

      app.innerHTML = inner;
      refreshVoiceUI();
    }

    function questionUI(blockName, item){
      let prompt, opts = null, kind='mc', inputType='text', dynAns=null;
      if (item.type === 'mc'){
        prompt = item.prompt; opts = shuffle([...item.options, 'Não me recordo']);
      } else if (item.type === 'mc-sent'){
        const q = item.questions[state.subIndex];
        prompt = q.prompt; opts = shuffle([...q.options, 'Não me recordo']);
      } else if (item.type === 'mc-dyn'){
        const d = dynamic(item.get); prompt = item.prompt; dynAns = d.answer; opts = shuffle([...d.options, 'Não me recordo']);
      } else if (item.type === 'input-dyn'){
        const d = dynamic(item.get); prompt = item.prompt; dynAns = d.answer; kind='input'; inputType=item.input||'text';
      }

      tts.say(prompt);
      return `
        ${header({codificacao:'Memorização', orientacao:'Orientação no Tempo', semantica:'Conhecimentos Gerais'}[blockName])}
        <p class="text-xl text-gray-700 mb-6 min-h-[60px]">${prompt}</p>
      ${kind==='mc' ? `
        <div class="option-grid">
          ${opts.map(o=>`<button class="option-btn" data-action="choose" data-value="${encodeURIComponent(o)}">${o}</button>`).join('')}
        </div>
      `: `
        <div><input id="free-input" class="input" type="${inputType}" placeholder="Digite sua resposta" autocomplete="off" /></div>
      `}
      <div class="flex items-center justify-between mt-4">
        <div class="text-sm text-gray-500 truncate"><span id="voice-transcript"></span></div>
        <div class="flex gap-2">
          <button class="btn-secondary btn" data-action="voice-start" data-mode="${kind==='mc'?'mc':'input'}">🎙️ Responder por voz</button>
          <button class="btn-secondary btn" data-action="voice-stop">Parar</button>
        </div>
      </div>
      <div class="mt-8 text-right">
        <button class="btn" data-action="submit" ${kind==='mc'?'disabled':''}>Confirmar</button>
      </div>
        ${dynAns!==null?`<span class="hidden" id="dyn-answer" data-ans="${encodeURIComponent(dynAns)}"></span>`:''}
      `;
    }

    // ==============================
    // EVOCAÇÃO LIVRE
    // ==============================
    function buildRecallPool(){
      let recallId = 0;
      const nextId = ()=>`recall-${recallId++}`;
      const words = blocks.codificacao
        .filter(i=>i.type==='mc')
        .map(i=>({id:nextId(), cue:i.cue, answer:i.answer, source:'word', recalled:null, response:null}));
      const sentSets = blocks.codificacao.filter(i=>i.type==='mc-sent');
      const sentItems = sentSets.flatMap((s,idx)=>
        s.recall_items.map(x=>({
          id:nextId(),
          cue:`Da frase sobre ${idx===0?'os gatos':'o garoto'}`,
          answer:x,
          source:`sentence_${idx+1}`,
          recalled:null,
          response:null
        }))
      );
      state.itemsToRecall = [...words, ...sentItems];
    }

    function renderFreeRecall(){
      if (state.recallPhase==='words') return renderFreeRecallWords();
      return renderFreeRecallSentences();
    }

    function renderFreeRecallWords(){
      const text = 'Agora, selecione as 5 palavras que você memorizou no início do teste.';
      const words = state.itemsToRecall.filter(i=>i.source==='word').map(i=>i.answer);
      const distractors = ['Maçã','Martelo','Cachorro','Violino','Azul','Pera','Chave','Tigre','Harpa','Roxo','Copo','Livro','Porta','Caneta','Garfo'];
      const pool = shuffle([...words, ...shuffle(distractors).slice(0,15)]);
      tts.say(text);
      app.innerHTML = `
        ${header('Evocação Livre — Palavras')}
        <p class="text-gray-700 mb-2">${text}</p>
        <div class="text-sm text-gray-600 mb-3">Toque para selecionar (máx. ${MAX_FREE_RECALL_WORDS}).</div>
        <div id="recall-grid" class="grid grid-cols-2 sm:grid-cols-4 gap-3">
          ${pool.map(o=>`<button class="option-btn text-center" data-action="toggle-recall" data-kind="word">${o}</button>`).join('')}
        </div>
        <div class="flex items-center justify-between mt-3">
          <div class="text-sm text-gray-500 truncate"><span id="voice-transcript"></span></div>
          <div class="flex gap-2">
            <button class="btn-secondary btn" data-action="voice-start" data-mode="recall-words">🎙️ Falar palavras</button>
            <button class="btn-secondary btn" data-action="voice-stop">Parar</button>
          </div>
        </div>
        <div class="mt-3 text-right text-sm">Selecionadas: <span id="sel-count" class="font-semibold">0</span> / ${MAX_FREE_RECALL_WORDS}</div>
        <div class="mt-6 text-right"><button class="btn" data-action="commit-recall-words">Confirmar seleção</button></div>
      `;
      refreshVoiceUI();
    }

    function renderFreeRecallSentences(){
      const text = 'Agora, selecione as palavras que você se lembra das duas frases apresentadas.';
      const items = state.itemsToRecall.filter(i=>/sentence_/.test(i.source)).map(i=>i.answer);
      const distractors = ['Vinte','Pretos','Ração','Pedro','Bola','Cão','Gata','Quarenta'];
      const pool = shuffle([...items, ...distractors]);
      tts.say(text);
      app.innerHTML = `
        ${header('Evocação Livre — Frases')}
        <p class="text-gray-700 mb-2">${text}</p>
        <div class="text-sm text-gray-600 mb-3">Selecione todas as palavras que lembrar.</div>
        <div id="recall-grid" class="grid grid-cols-2 sm:grid-cols-3 gap-3">
          ${pool.map(o=>`<button class="option-btn text-center" data-action="toggle-recall" data-kind="sent">${o}</button>`).join('')}
        </div>
        <div class="flex items-center justify-between mt-3">
          <div class="text-sm text-gray-500 truncate"><span id="voice-transcript"></span></div>
          <div class="flex gap-2">
            <button class="btn-secondary btn" data-action="voice-start" data-mode="recall-sent">🎙️ Falar itens</button>
            <button class="btn-secondary btn" data-action="voice-stop">Parar</button>
          </div>
        </div>
        <div class="mt-6 text-right"><button class="btn" data-action="commit-recall-sent">Confirmar e continuar</button></div>
      `;
      refreshVoiceUI();
    }

    // ==============================
    // EVOCAÇÃO COM PISTAS
    // ==============================
    function renderCuedRecall(){
      const remainingItems = state.itemsToRecall.filter(i=>!i.recalled);
      const pending = remainingItems[0];
      if (!pending){
        state.scores.recuperacao_pistas = state.itemsToRecall.filter(i=>i.recalled === 'cued').length;
        return goNext();
      }
      const distractorMap = {
        fruta:['Maçã','Banana','Uva'], ferramenta:['Serrote','Martelo','Alicate'],
        animal:['Gato','Leão','Cachorro'], instrumento:['Violino','Flauta','Guitarra'],
        cor:['Azul','Amarelo','Vermelho'], gatos:['Vinte','Pretos','Ração'], garoto:['Pedro','Bola','Carrinho']
      };
      const key = Object.keys(distractorMap).find(k=> pending.cue.toLowerCase().includes(k));
      const distract = (key? distractorMap[key]: ['Opção A','Opção B']).filter(d=>d!==pending.answer);
      const opts = shuffle([pending.answer, ...shuffle(distract).slice(0,3), 'Não me recordo']);

      state.selection = null;
      app.innerHTML = `
        ${header('Evocação com Pistas')}
        <p class="text-sm text-gray-500 mb-2">Itens restantes: ${remainingItems.length}</p>
        <p class="text-xl text-gray-700 mb-6">${pending.cue}</p>
        <div class="option-grid">
          ${opts.map(o=>`<button class="option-btn" data-action="choose" data-value="${encodeURIComponent(o)}">${o}</button>`).join('')}
        </div>
        <div class="flex items-center justify-between mt-4">
          <div class="text-sm text-gray-500 truncate"><span id="voice-transcript"></span></div>
          <div class="flex gap-2">
            <button class="btn-secondary btn" data-action="voice-start" data-mode="cued">🎙️ Responder por voz</button>
            <button class="btn-secondary btn" data-action="voice-stop">Parar</button>
          </div>
        </div>
        <div class="mt-8 text-right"><button class="btn" data-action="submit-cued" data-item="${encodeURIComponent(JSON.stringify(pending))}" disabled>Confirmar</button></div>
      `;
      state.lastShownAt = performance.now();
      tts.say(pending.cue);
      refreshVoiceUI();
    }

    // ==============================
    // LÓGICA DE FLUXO
    // ==============================
    function startTest(){
      state.startTime = new Date();
      state.orientationReference = null;
      state.speech = { supported:state.speech.supported, listening:false, utterances:0, log:[] };
      state.screen = 'test';
      state.block = FLOW[0];
      state.itemIndex = 0; state.subIndex = 0;
      buildRecallPool();
      render();
    }

    function goNext(){
      asr.stop();
      // avança dentro do bloco atual
      if (blocks[state.block]){
        const arr = blocks[state.block];
        const curr = arr[state.itemIndex];
        if (curr?.type==='mc-sent' && state.subIndex < curr.questions.length-1){
          state.subIndex++;
        } else {
          state.itemIndex++; state.subIndex = 0;
        }
        if (state.itemIndex < arr.length){ render(); return; }
      }
      // fim do bloco -> próximo
      const i = FLOW.indexOf(state.block);
      if (i < FLOW.length-1){
        state.block = FLOW[i+1];
        if (state.block === 'orientacao' && !state.orientationReference){
          state.orientationReference = new Date();
        }
        state.itemIndex = 0; state.subIndex = 0;
        render(); return;
      }
      // fim do teste
      state.endTime = new Date();
      state.screen = 'results';
      render();
    }

    function scoreAndLog(answer, correct, domain){
      const now = performance.now();
      const rt = Math.max(0, now - (state.lastShownAt||now));
      state.rtLog.push({block:domain, item:state.itemIndex, sub:state.subIndex, answer, correct, rt});
      if (rt < 200) state.qc.push(`Resposta muito rápida (${Math.round(rt)}ms) em ${domain}-${state.itemIndex}`);
      const ok = answersMatch(answer, correct);
      if (ok) state.scores[domain]++;
      const key = `${domain}-${state.itemIndex}-${state.subIndex}`;
      state.answers[key] = {given:answer, correct, isCorrect:ok, rt};
    }

    function registerCuedRecallAnswer(item, answer){
      const given = String(answer ?? '');
      const correct = String(item?.answer ?? '');
      if (!given){ return; }

      const rt = Math.max(0, performance.now() - (state.lastShownAt || performance.now()));
      const ok = answersMatch(given, correct);
      let ref = state.itemsToRecall.find(i=>i.id && item?.id && i.id === item.id);
      if (!ref){
        ref = state.itemsToRecall.find(i=>i.cue===item.cue && answersMatch(i.answer, correct));
      }

      if (ref && ref.recalled === 'free'){ return; }

      if (ref){
        ref.recalled = ok ? 'cued' : 'missed';
        ref.response = given;
      }

      const key = `recuperacao_pistas-${item.cue}-${correct}`;
      state.answers[key] = { given, correct, cue:item.cue, isCorrect:ok, rt };
      state.rtLog.push({ block:'recuperacao_pistas', item:item.cue, answer:given, correct, rt, isCorrect:ok });
      if (rt < 200) state.qc.push(`Resposta muito rápida (${Math.round(rt)}ms) na evocação com pistas (${item.cue})`);

      state.scores.recuperacao_pistas = state.itemsToRecall.filter(i=>i.recalled === 'cued').length;
    }

    // ==============================
    // EXPORTAÇÃO
    // ==============================
    function exportData(){
      if (!state.recallStats) summarizeRecall();
      const stats = state.recallStats || computeRecallStats();
      const totalScore = state.scores.codificacao + state.scores.orientacao + state.scores.semantica + state.scores.recuperacao_livre + state.scores.recuperacao_pistas;
      const totalMax = 10 + 5 + 15 + 10 + 10;
      return {
        version: TEST_VERSION,
        testDate: state.startTime?.toISOString?.()||'',
        durationSec: state.endTime? Math.round((state.endTime - state.startTime)/1000):0,
        orientationReference: state.orientationReference? new Date(state.orientationReference).toISOString():null,
        profile: state.profile,
        scores: {
          codificacao: {score:state.scores.codificacao, max:10},
          orientacao: {score:state.scores.orientacao, max:5},
          semantica: {score:state.scores.semantica, max:15},
          recuperacao_livre: {score:state.scores.recuperacao_livre, max:10},
          recuperacao_pistas: {score:state.scores.recuperacao_pistas, max:10},
          total: {score:totalScore, max:totalMax}
        },
        derived: {
          cuedEligible: stats.eligible,
          cuedRecovered: stats.cueHits,
          cuedAutoCredit: stats.autoAwarded ? stats.totalTargets : 0,
          recuperacao_total: stats.totalTargets - stats.missed,
          voice: { supported: state.speech.supported, used: state.speech.utterances>0, utterances: state.speech.utterances }
        },
        qc: state.qc,
        answers: state.answers,
        recall: state.itemsToRecall,
        rt: state.rtLog,
        speechLog: state.speech.log
      };
    }

    function download(filename, content, type){
      const blob = new Blob([content], {type});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url; a.download = filename; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
    }
    
    function exportPDF(){
      const { jsPDF } = window.jspdf;
      const data = exportData();
      const doc = new jsPDF();
      const timestamp = new Date().toISOString().replace(/[:.]/g,'-');

      doc.setFontSize(20);
      doc.setFont('helvetica', 'bold');
      doc.text("M@T Digital - Relatório de Resultados", 105, 20, { align: 'center' });
      doc.setFontSize(10);
      doc.setFont('helvetica', 'normal');
      doc.text(data.version, 105, 28, { align: 'center' });
      doc.setFontSize(12);
      doc.text(`Data: ${new Date(data.testDate).toLocaleString('pt-BR')}`, 20, 45);
      const duration = data.durationSec;
      const mm = Math.floor(duration/60);
      const ss = duration % 60;
      doc.text(`Duração: ${mm}m ${ss}s`, 20, 53);
      const voiceInfo = data.derived?.voice || {used:false,utterances:0};
      doc.text(`Respostas por voz: ${voiceInfo.used ? 'Sim' : 'Não'} (enunciados: ${voiceInfo.utterances || 0})`, 20, 61);
      doc.setFontSize(14);
      doc.setFont('helvetica', 'bold');
      doc.text("Perfil do Participante", 20, 76);
      doc.setFontSize(11);
      doc.setFont('helvetica', 'normal');
      doc.text(`Idade: ${data.profile.age} anos`, 20, 84);
      doc.text(`Escolaridade: ${data.profile.education} anos`, 20, 92);
      doc.setFontSize(14);
      doc.setFont('helvetica', 'bold');
      doc.text("Pontuação por Domínio", 20, 108);

      const betterLabels = {
        codificacao: 'Memorização (Codificação)',
        orientacao: 'Orientação no Tempo',
        semantica: 'Conhecimentos Gerais',
        recuperacao_livre: 'Evocação Livre',
        recuperacao_pistas: 'Evocação com Pistas',
        total: 'PONTUAÇÃO TOTAL'
      };
      const tableData = Object.entries(data.scores).map(([key, value]) => {
        return [ betterLabels[key] || key, `${value.score}`, `${value.max}`];
      });

      doc.autoTable({
        startY: 113,
        head: [['Domínio', 'Pontuação', 'Máximo']],
        body: tableData,
        theme: 'grid',
        headStyles: { fillColor: [59, 130, 246] },
        didDrawCell: (data) => {
          if (data.row.index === tableData.length - 1) { // Total row
            doc.setFont(undefined, 'bold');
          }
        }
      });
      let y = doc.autoTable.previous.finalY + 10;
      const eligibleCued = (data.recall || []).filter(i=>i.recalled && i.recalled !== 'free').length;
      doc.setFontSize(10);
      doc.setFont('helvetica', 'normal');
      doc.text(`Itens elegíveis por pistas: ${eligibleCued}`, 20, y);
      y += 8;
      if (data.qc.length > 0) {
        doc.setFontSize(12);
        doc.setFont('helvetica', 'bold');
        doc.text("Observações de Qualidade:", 20, y);
        y += 8;
        doc.setFontSize(10);
        doc.setFont('helvetica', 'normal');
        data.qc.forEach(flag => {
          if (y > 270) { doc.addPage(); y = 20; }
          const lines = doc.splitTextToSize(`• ${flag}`, 170);
          doc.text(lines, 25, y);
          y += lines.length * 5;
        });
      }
      doc.setFontSize(8);
      doc.setFont('helvetica', 'italic');
      doc.text("Este relatório é para fins de rastreio. A interpretação deve ser realizada por profissional qualificado.", 105, 285, { align: 'center' });
      doc.save(`MAT_Digital_${timestamp}.pdf`);
    }


    // ==============================
    // RESULTADOS
    // ==============================
    function renderResults(){
      asr.stop();
      const stats = summarizeRecall();
      const data = exportData();
      const total = data.scores.total.score;
      const duration = data.durationSec; const mm = Math.floor(duration/60); const ss = duration%60;
      const eligibleCued = stats.eligible;
      const cuesRecovered = stats.cueHits;
      const eligibleNote = eligibleCued === 0
        ? 'Nenhum item precisou de pista (pontuação máxima atribuída).'
        : `Itens elegíveis por pistas: ${eligibleCued} - Recuperadas com pistas: ${cuesRecovered}`;
      const row = (label, sc, max, strong=false)=>`
        <div class="flex justify-between items-center ${strong?'bg-blue-100 border-2 border-blue-300':'bg-gray-50'} p-3 rounded-lg">
          <span class="${strong?'font-bold text-blue-800':'font-semibold text-gray-700'}">${label}</span>
          <span class="${strong?'text-xl font-bold text-blue-800':'text-lg font-bold text-gray-800'}">${sc} / ${max}</span>
        </div>`;
      app.innerHTML = `
        <div class="text-center">
          <h2 class="text-3xl font-bold text-gray-800 mb-1">Teste concluído</h2>
          <p class="text-gray-600 mb-6">Tempo total: ${mm}m ${ss}s</p>
        </div>
        <div class="space-y-3">
          ${row('Memorização (Codificação)', data.scores.codificacao.score, data.scores.codificacao.max)}
          ${row('Orientação no Tempo', data.scores.orientacao.score, data.scores.orientacao.max)}
          ${row('Conhecimentos Gerais', data.scores.semantica.score, data.scores.semantica.max)}
          ${row('Evocação Livre', data.scores.recuperacao_livre.score, data.scores.recuperacao_livre.max)}
          ${row('Evocação com Pistas', data.scores.recuperacao_pistas.score, data.scores.recuperacao_pistas.max)}
          <div class="text-xs text-gray-500 text-right">${eligibleNote}</div>
          ${row('PONTUAÇÃO TOTAL', total, data.scores.total.max, true)}
        </div>
        ${state.qc.length?`
        <div class="mt-6 p-3 bg-yellow-50 border-l-4 border-yellow-400 text-yellow-900 rounded">
          <h4 class="font-bold mb-2">Observações de Qualidade</h4>
          <ul class="list-disc list-inside text-sm space-y-1">${state.qc.map(x=>`<li>${x}</li>`).join('')}</ul>
        </div>`:''}
        <div class="mt-8">
          <h3 class="text-lg font-semibold text-center mb-3">Exportar resultados</h3>
          <div class="grid grid-cols-1 sm:grid-cols-3 gap-3">
            <button class="btn-secondary btn" data-action="export-json">💾 JSON</button>
            <button class="btn-secondary btn" data-action="export-csv">📊 CSV</button>
            <button class="btn-secondary btn" data-action="export-pdf">📄 PDF</button>
          </div>
        </div>
        <div class="mt-8 text-center"><button class="btn" data-action="restart">Novo teste</button></div>
        <div class="mt-6 p-3 bg-blue-50 border border-blue-200 rounded text-sm text-blue-800">
          <p class="font-semibold mb-1">Nota importante:</p>
          <p>Este é um teste de rastreio cognitivo. A interpretação dos resultados deve ser realizada por profissional habilitado.</p>
        </div>
      `;
      refreshVoiceUI();
    }

    // ==============================
    // EVENTOS
    // ==============================
    app.addEventListener('click', (ev)=>{
      const btn = ev.target.closest('[data-action]'); if(!btn) return;
      const act = btn.getAttribute('data-action');
      if (act==='test-audio'){
        tts.ensureReady();
        tts.say('Teste de áudio habilitado. Você ouvirá as instruções durante o exame.');
      }
      else if (act==='start-profile'){ state.screen='profile'; render(); }
      else if (act==='back'){ state.screen='welcome'; render(); }
      else if (act==='go-instructions'){
        const age = $('#age').value.trim(); const edu = $('#education').value.trim();
        const err = $('#profile-error');
        if (!age || !edu){ err.textContent='Preencha todos os campos obrigatórios.'; return; }
        state.profile.age = age; state.profile.education = edu; state.screen='instructions'; render();
      }
      else if (act==='back-profile'){ state.screen='profile'; render(); }
      else if (act==='start-test'){
        tts.ensureReady(); startTest();
      }
      else if (act==='next'){ goNext(); }
      else if (act==='choose'){
        state.selection = decodeURIComponent(btn.getAttribute('data-value'));
        $$('.option-btn').forEach(b=>b.classList.remove('selected'));
        btn.classList.add('selected');
        const submit = $('[data-action="submit"], [data-action="submit-cued"]');
        if (submit){ submit.disabled=false; }
      }
      else if (act==='submit'){
        asr.stop();
        const arr = blocks[state.block]; const item = arr[state.itemIndex];
        let given = state.selection;
        if (item.type==='input-dyn'){
          given = ($('#free-input')?.value||'').trim();
          if (!given){ return; }
        }
        // Determinar resposta correta
        let correct;
        if (item.type==='mc') correct = item.answer;
        else if (item.type==='mc-sent') correct = item.questions[state.subIndex].answer;
        else if (item.type==='mc-dyn' || item.type==='input-dyn') correct = decodeURIComponent($('#dyn-answer').getAttribute('data-ans'));
        scoreAndLog(given, correct, state.block);
        if (state.block==='codificacao' && (item.type==='mc' || item.type==='mc-sent')){
          // feedback visual breve
          $$('.option-btn').forEach(b=>{
            const val = decodeURIComponent(b.getAttribute('data-value'));
            b.disabled = true;
            if (val.toLowerCase()===String(correct).toLowerCase()) b.classList.add('correct');
            else if (val===state.selection) b.classList.add('incorrect');
          });
          const msg = (String(given).toLowerCase()===String(correct).toLowerCase())? 'Correto.' : `A resposta correta era: ${correct}.`;
          tts.say(msg, { onend: ()=> setTimeout(()=>{ goNext(); }, 500) });
        } else {
          goNext();
        }
      }
      else if (act==='toggle-recall'){
        btn.classList.toggle('selected');
        if (btn.getAttribute('data-kind')==='word'){
          const sel = $$('#recall-grid .option-btn.selected');
          if (sel.length > MAX_FREE_RECALL_WORDS){ btn.classList.remove('selected'); return; }
          $('#sel-count').textContent = String(sel.length);
          const rest = $$('#recall-grid .option-btn:not(.selected)');
          rest.forEach(x=>{ x.disabled = sel.length>=MAX_FREE_RECALL_WORDS; });
        }
      }
      else if (act==='commit-recall-words'){
        asr.stop();
        const chosen = $$('#recall-grid .option-btn.selected').map(b=>b.textContent.trim());
        chosen.forEach(w=>{
        const it = state.itemsToRecall.find(i=>i.source==='word' && !i.recalled && answersMatch(i.answer, w));
        if (it){ it.recalled='free'; it.response = w; state.scores.recuperacao_livre++; }
      });
      state.recallPhase='sent'; render();
    }
      else if (act==='commit-recall-sent'){
        asr.stop();
        const chosen = $$('#recall-grid .option-btn.selected').map(b=>b.textContent.trim());
        chosen.forEach(w=>{
        const it = state.itemsToRecall.find(i=>/sentence_/.test(i.source) && !i.recalled && answersMatch(i.answer, w));
        if (it){ it.recalled='free'; it.response = w; state.scores.recuperacao_livre++; }
      });
      goNext();
    }
      else if (act==='submit-cued'){
        asr.stop();
        const raw = btn.getAttribute('data-item');
        const item = JSON.parse(decodeURIComponent(raw));
        const ans = state.selection || '';
        registerCuedRecallAnswer(item, ans);
        state.selection = null;
        renderCuedRecall();
      }
      else if (act==='restart'){
        if (confirm('Reiniciar o teste? O progresso atual será perdido.')){ asr.stop(); Object.assign(state, {
          screen:'welcome', profile:{age:'',education:''}, block:null, itemIndex:0, subIndex:0, startTime:null, endTime:null,
          answers:{}, scores:{codificacao:0, orientacao:0, semantica:0, recuperacao_livre:0, recuperacao_pistas:0},
          itemsToRecall:[], recallPhase:'words', selection:null, lastShownAt:null, rtLog:[], qc:[], ttsReady:state.ttsReady,
          orientationReference:null, recallStats:null,
          speech:{ supported:state.speech.supported, listening:false, utterances:0, log:[] }
        }); render(); }
      }
      else if (act==='export-json'){
        const d = exportData(); const ts = new Date().toISOString().replace(/[:.]/g,'-');
        download(`MAT_Digital_${ts}.json`, JSON.stringify(d,null,2), 'application/json');
      }
      else if (act==='export-csv'){
        const d = exportData(); const ts = new Date().toISOString().replace(/[:.]/g,'-');
        let csv = 'Dominio,Pontuacao,Maximo,Percentual\n';
        const rows = [ ['Codificacao', d.scores.codificacao.score, d.scores.codificacao.max],
                          ['Orientacao', d.scores.orientacao.score, d.scores.orientacao.max],
                          ['Semantica', d.scores.semantica.score, d.scores.semantica.max],
                          ['Recuperacao Livre', d.scores.recuperacao_livre.score, d.scores.recuperacao_livre.max],
                          ['Recuperacao Pistas', d.scores.recuperacao_pistas.score, d.scores.recuperacao_pistas.max],
                          ['Total', d.scores.total.score, d.scores.total.max] ];
        rows.forEach(([k,sc,max])=>{ const pct=((sc/max)*100).toFixed(1)+'%'; csv+=`${k},${sc},${max},${pct}\n`; });
        csv += '\nPerfil\n';
        csv += `Idade,${d.profile.age}\n`;
        csv += `Escolaridade,${d.profile.education}\n`;
        csv += `Data,${new Date(d.testDate||Date.now()).toLocaleString('pt-BR')}\n`;
        download(`MAT_Digital_${ts}.csv`, csv, 'text/csv;charset=utf-8;');
      }
      else if (act==='export-pdf'){
        exportPDF();
      }
      else if (act==='voice-start'){
        const mode = btn.getAttribute('data-mode') || 'mc';
        asr.start({mode});
      }
      else if (act==='voice-stop'){
        asr.stop();
      }
    });

    app.addEventListener('keypress', (e)=>{
      if (e.key==='Enter' && e.target.id==='free-input'){
        const submit = $('[data-action="submit"]'); if (submit && !submit.disabled) submit.click();
      }
    });

    // Qualidade: saída da aba
    document.addEventListener('visibilitychange', ()=>{
      if (document.hidden && state.screen==='test'){
        state.qc.push(`Saiu da aba às ${new Date().toLocaleTimeString('pt-BR')}`);
      }
    });
    window.addEventListener('beforeunload', (e)=>{
      if (state.screen==='test'){ e.preventDefault(); e.returnValue = 'Sair agora apagará o progresso do teste.'; }
    });

    // BOOT
    asr.init();
    render();
  </script>
</body>
</html>
